/*
	深度优先搜索---不撞男墙不回头
	输入一个数n,输入1~n的全排列。
	理解深度优先搜索的关键在于"当下该如何做"。至于"下一步怎么做"
	和当下做是一样的。每一种可能都去尝试一遍(for循环遍历)
	当前这一步解决后便进入到下一步dfs(step+1)
*/
#include<stdio.h>
int a[10], book[10], n;
void dfs(int step)//表示站在了第几个盒子前面
{
	int i;
	if(step == n+1)//如果站在了第n+1个盒子面前,则表示前n个盒子已经放好了扑克牌
	{
		//输出一种排列
		{
			for(i = 1; i <= n; i++)
				printf("%d", a[i]);
			printf("\n");

			return;//返回之前的一步
		}
	}

	//此时站在了第step的盒子前面,应该放的牌
	//按照1,2,3，....n的顺序一一尝试
	for(i=1; i<=n; i++)
	{
		//判断扑克牌i是否还在手上
		if(book[i] == 0)
		{
			//开始尝试使用扑克牌i
			a[step] = i;//将第i号扑克牌放入到第step个盒子中
			book[i] = 1;//表示这个数字不能使用了

			//第step个盒子已经放好了扑克牌，接下来需要到下一个盒子
			dfs(step+1);
			book[i] = 0;//将扑克牌回收，进行下一次尝试
		}
	}
}
int main ()
{
	scanf("%d", &n);//n为1到9之间的整数
	dfs(1);
	return 0;
}